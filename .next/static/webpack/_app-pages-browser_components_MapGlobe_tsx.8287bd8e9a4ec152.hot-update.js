"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_components_MapGlobe_tsx",{

/***/ "(app-pages-browser)/./components/MapGlobe.tsx":
/*!*********************************!*\
  !*** ./components/MapGlobe.tsx ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ MapGlobe; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var maplibre_gl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! maplibre-gl */ \"(app-pages-browser)/./node_modules/maplibre-gl/dist/maplibre-gl.js\");\n/* harmony import */ var maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(maplibre_gl__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _utils_pingCalculator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/utils/pingCalculator */ \"(app-pages-browser)/./utils/pingCalculator.ts\");\n/* harmony import */ var maplibre_gl_dist_maplibre_gl_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! maplibre-gl/dist/maplibre-gl.css */ \"(app-pages-browser)/./node_modules/maplibre-gl/dist/maplibre-gl.css\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nfunction MapGlobe() {\n    _s();\n    const mapContainer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const markersRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const pointsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const [pingTime, setPingTime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"N/A\");\n    // Initialize map\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (map.current) return; // Only initialize once\n        if (mapContainer.current) {\n            // Create the map with a standard style\n            map.current = new (maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default().Map)({\n                container: mapContainer.current,\n                style: {\n                    version: 8,\n                    sources: {\n                        \"raster-tiles\": {\n                            type: \"raster\",\n                            tiles: [\n                                \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\"\n                            ],\n                            tileSize: 256,\n                            attribution: \"\\xa9 OpenStreetMap contributors\"\n                        }\n                    },\n                    layers: [\n                        {\n                            id: \"simple-tiles\",\n                            type: \"raster\",\n                            source: \"raster-tiles\",\n                            minzoom: 0,\n                            maxzoom: 19\n                        }\n                    ]\n                },\n                center: [\n                    0,\n                    0\n                ],\n                zoom: 1,\n                pitch: 0,\n                bearing: 0\n            });\n            // Set dark background for the map\n            mapContainer.current.style.background = \"#000\";\n            // Add navigation control\n            map.current.addControl(new (maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default().NavigationControl)());\n            // Add attribution\n            map.current.addControl(new (maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default().AttributionControl)({\n                customAttribution: \"\\xa9 OpenStreetMap contributors\"\n            }), \"bottom-right\");\n            // Add click handler for adding markers\n            map.current.on(\"click\", (e)=>{\n                console.log(\"Map clicked at:\", e.lngLat);\n                const { lng, lat } = e.lngLat;\n                console.log(\"Adding marker at: lng=\".concat(lng, \", lat=\").concat(lat));\n                addMarker(lng, lat);\n            });\n            // Add debug listener for map load\n            map.current.on(\"load\", ()=>{\n                var // Set globe projection after map is loaded\n                _map_current;\n                console.log(\"Map loaded\");\n                (_map_current = map.current) === null || _map_current === void 0 ? void 0 : _map_current.setProjection({\n                    type: \"globe\"\n                });\n                console.log(\"Globe projection set\");\n            });\n            // Add debug listener for style load\n            map.current.on(\"style.load\", ()=>{\n                console.log(\"Map style loaded\");\n            });\n        }\n        // Cleanup on unmount\n        return ()=>{\n            markersRef.current.forEach((marker)=>marker.remove());\n            if (map.current) {\n                map.current.remove();\n                map.current = null;\n            }\n        };\n    }, []);\n    // Function to add a marker at the specified coordinates\n    const addMarker = (lng, lat)=>{\n        if (!map.current) return;\n        console.log(\"Adding marker at:\", [\n            lng,\n            lat\n        ]);\n        // Manage markers directly with refs instead of state\n        // If we already have 2 markers, remove the first one\n        if (markersRef.current.length >= 2) {\n            const oldMarker = markersRef.current.shift();\n            oldMarker === null || oldMarker === void 0 ? void 0 : oldMarker.remove();\n            pointsRef.current.shift();\n        }\n        // Determine if this will be the first or second marker in the pair\n        const isFirstInPair = markersRef.current.length === 0;\n        const markerColor = isFirstInPair ? \"#ff3b30\" : \"#007aff\" // Red for first, blue for second\n        ;\n        // Create marker element\n        const el = document.createElement(\"div\");\n        el.className = \"marker\";\n        el.style.backgroundColor = markerColor;\n        console.log(\"Adding \".concat(isFirstInPair ? \"first (red)\" : \"second (blue)\", \" marker in pair\"));\n        // Create and add the marker\n        const marker = new (maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default().Marker)({\n            element: el,\n            anchor: \"center\"\n        }).setLngLat([\n            lng,\n            lat\n        ]).addTo(map.current);\n        // Add to our refs\n        markersRef.current.push(marker);\n        pointsRef.current.push([\n            lat,\n            lng\n        ]);\n        console.log(\"Current markers count:\", markersRef.current.length);\n        console.log(\"Current points:\", pointsRef.current);\n        // Draw line between points if we have exactly two\n        if (markersRef.current.length === 2) {\n            console.log(\"We have 2 markers, drawing line and calculating ping\");\n            drawRouteAndCalculatePing(pointsRef.current);\n        } else {\n            // Remove existing line if present\n            if (map.current.getSource(\"route\")) {\n                try {\n                    map.current.removeLayer(\"route-line\");\n                    map.current.removeLayer(\"route-glow\");\n                    map.current.removeSource(\"route\");\n                } catch (e) {\n                    console.error(\"Error removing existing layers:\", e);\n                }\n            }\n        }\n    };\n    // Separate function to draw route and calculate ping\n    const drawRouteAndCalculatePing = (routePoints)=>{\n        if (!map.current || routePoints.length !== 2) return;\n        // Get coordinates in correct format for calculations\n        const [lat1, lng1] = routePoints[0];\n        const [lat2, lng2] = routePoints[1];\n        console.log(\"Calculating ping time between:\", \"Point 1: \".concat(lat1, \", \").concat(lng1), \"Point 2: \".concat(lat2, \", \").concat(lng2));\n        const time = (0,_utils_pingCalculator__WEBPACK_IMPORTED_MODULE_3__.calculateTheoreticalPingTime)(lat1, lng1, lat2, lng2);\n        const distance = (0,_utils_pingCalculator__WEBPACK_IMPORTED_MODULE_3__.calculateGreatCircleDistance)(lat1, lng1, lat2, lng2);\n        console.log(\"Calculated values:\", {\n            time,\n            distance\n        });\n        // Format the ping time\n        const formattedTime = (0,_utils_pingCalculator__WEBPACK_IMPORTED_MODULE_3__.formatPingTime)(time);\n        setPingTime(formattedTime);\n        // Remove existing line if present\n        if (map.current.getSource(\"route\")) {\n            try {\n                map.current.removeLayer(\"route-line\");\n                map.current.removeLayer(\"route-glow\");\n                map.current.removeSource(\"route\");\n            } catch (e) {\n                console.error(\"Error removing existing layers:\", e);\n            }\n        }\n        // Add the new line source with coordinates in [lng, lat] format for GeoJSON\n        map.current.addSource(\"route\", {\n            type: \"geojson\",\n            data: {\n                type: \"Feature\",\n                properties: {},\n                geometry: {\n                    type: \"LineString\",\n                    coordinates: [\n                        [\n                            lng1,\n                            lat1\n                        ],\n                        [\n                            lng2,\n                            lat2\n                        ]\n                    ]\n                }\n            }\n        });\n        console.log(\"Added route source with coordinates:\", [\n            [\n                lng1,\n                lat1\n            ],\n            [\n                lng2,\n                lat2\n            ]\n        ]);\n        // Add the glow layer first\n        map.current.addLayer({\n            id: \"route-glow\",\n            type: \"line\",\n            source: \"route\",\n            layout: {\n                \"line-join\": \"round\",\n                \"line-cap\": \"round\"\n            },\n            paint: {\n                \"line-color\": \"#4db8ff\",\n                \"line-width\": 15,\n                \"line-opacity\": 0.8,\n                \"line-blur\": 15\n            }\n        });\n        console.log(\"Added glow layer\");\n        // Add the main line layer on top\n        map.current.addLayer({\n            id: \"route-line\",\n            type: \"line\",\n            source: \"route\",\n            layout: {\n                \"line-join\": \"round\",\n                \"line-cap\": \"round\"\n            },\n            paint: {\n                \"line-color\": \"#ffffff\",\n                \"line-width\": 5,\n                \"line-opacity\": 1,\n                \"line-dasharray\": [\n                    0.5,\n                    1\n                ]\n            }\n        });\n        console.log(\"Added line layer\");\n        // Calculate midpoint for popup\n        const midLat = (lat1 + lat2) / 2;\n        const midLng = (lng1 + lng2) / 2;\n        // Remove existing popups\n        const existingPopups = document.getElementsByClassName(\"ping-popup\");\n        Array.from(existingPopups).forEach((popup)=>popup.remove());\n        // Add the ping time popup\n        new (maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default().Popup)({\n            closeButton: false,\n            closeOnClick: false,\n            className: \"ping-popup\",\n            anchor: \"center\"\n        }).setLngLat([\n            midLng,\n            midLat\n        ]).setHTML('\\n        <div class=\"text-center p-2\">\\n          <div class=\"font-bold text-lg text-blue-400\">'.concat(formattedTime, '</div>\\n          <div class=\"text-sm\">Distance: ').concat(distance.toFixed(0), \" km</div>\\n        </div>\\n      \")).addTo(map.current);\n        console.log(\"Added popup with ping time:\", formattedTime);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"instructions absolute top-4 left-4 z-10 bg-black/70 p-4 rounded-lg text-white max-w-md\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                        className: \"text-xl font-bold mb-2\",\n                        children: \"Instructions:\"\n                    }, void 0, false, {\n                        fileName: \"/Users/john/Documents/colour_coding/ping-map/components/MapGlobe.tsx\",\n                        lineNumber: 274,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        children: \"Click on two different locations on the globe to calculate the theoretical minimum ping time between them.\"\n                    }, void 0, false, {\n                        fileName: \"/Users/john/Documents/colour_coding/ping-map/components/MapGlobe.tsx\",\n                        lineNumber: 275,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"mt-4 p-2 bg-gray-800 rounded\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                children: \"Theoretical Minimum Ping Time: \"\n                            }, void 0, false, {\n                                fileName: \"/Users/john/Documents/colour_coding/ping-map/components/MapGlobe.tsx\",\n                                lineNumber: 278,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"font-bold text-xl text-blue-400\",\n                                children: pingTime\n                            }, void 0, false, {\n                                fileName: \"/Users/john/Documents/colour_coding/ping-map/components/MapGlobe.tsx\",\n                                lineNumber: 279,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/john/Documents/colour_coding/ping-map/components/MapGlobe.tsx\",\n                        lineNumber: 277,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/john/Documents/colour_coding/ping-map/components/MapGlobe.tsx\",\n                lineNumber: 273,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: mapContainer,\n                className: \"map-container\",\n                style: {\n                    width: \"100%\",\n                    height: \"100vh\"\n                }\n            }, void 0, false, {\n                fileName: \"/Users/john/Documents/colour_coding/ping-map/components/MapGlobe.tsx\",\n                lineNumber: 283,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}\n_s(MapGlobe, \"8Ro51RQZ2ql0D+Mtb099fzMebfg=\");\n_c = MapGlobe;\nvar _c;\n$RefreshReg$(_c, \"MapGlobe\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvTWFwR2xvYmUudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFFbUQ7QUFDZjtBQUMrRTtBQUMxRTtBQUUxQixTQUFTTzs7SUFDdEIsTUFBTUMsZUFBZVAsNkNBQU1BLENBQWlCO0lBQzVDLE1BQU1RLE1BQU1SLDZDQUFNQSxDQUF3QjtJQUMxQyxNQUFNUyxhQUFhVCw2Q0FBTUEsQ0FBc0IsRUFBRTtJQUNqRCxNQUFNVSxZQUFZViw2Q0FBTUEsQ0FBMEIsRUFBRTtJQUNwRCxNQUFNLENBQUNXLFVBQVVDLFlBQVksR0FBR1gsK0NBQVFBLENBQVM7SUFFakQsaUJBQWlCO0lBQ2pCRixnREFBU0EsQ0FBQztRQUNSLElBQUlTLElBQUlLLE9BQU8sRUFBRSxRQUFPLHVCQUF1QjtRQUUvQyxJQUFJTixhQUFhTSxPQUFPLEVBQUU7WUFDeEIsdUNBQXVDO1lBQ3ZDTCxJQUFJSyxPQUFPLEdBQUcsSUFBSVgsd0RBQWMsQ0FBQztnQkFDL0JhLFdBQVdSLGFBQWFNLE9BQU87Z0JBQy9CRyxPQUFPO29CQUNMQyxTQUFTO29CQUNUQyxTQUFTO3dCQUNQLGdCQUFnQjs0QkFDZEMsTUFBTTs0QkFDTkMsT0FBTztnQ0FBQzs2QkFBaUQ7NEJBQ3pEQyxVQUFVOzRCQUNWQyxhQUFhO3dCQUNmO29CQUNGO29CQUNBQyxRQUFRO3dCQUNOOzRCQUNFQyxJQUFJOzRCQUNKTCxNQUFNOzRCQUNOTSxRQUFROzRCQUNSQyxTQUFTOzRCQUNUQyxTQUFTO3dCQUNYO3FCQUNEO2dCQUNIO2dCQUNBQyxRQUFRO29CQUFDO29CQUFHO2lCQUFFO2dCQUNkQyxNQUFNO2dCQUNOQyxPQUFPO2dCQUNQQyxTQUFTO1lBQ1g7WUFFQSxrQ0FBa0M7WUFDbEN4QixhQUFhTSxPQUFPLENBQUNHLEtBQUssQ0FBQ2dCLFVBQVUsR0FBRztZQUV4Qyx5QkFBeUI7WUFDekJ4QixJQUFJSyxPQUFPLENBQUNvQixVQUFVLENBQUMsSUFBSS9CLHNFQUE0QjtZQUV2RCxrQkFBa0I7WUFDbEJNLElBQUlLLE9BQU8sQ0FBQ29CLFVBQVUsQ0FBQyxJQUFJL0IsdUVBQTZCLENBQUM7Z0JBQ3ZEa0MsbUJBQW1CO1lBQ3JCLElBQUk7WUFFSix1Q0FBdUM7WUFDdkM1QixJQUFJSyxPQUFPLENBQUN3QixFQUFFLENBQUMsU0FBUyxDQUFDQztnQkFDdkJDLFFBQVFDLEdBQUcsQ0FBQyxtQkFBbUJGLEVBQUVHLE1BQU07Z0JBQ3ZDLE1BQU0sRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUUsR0FBR0wsRUFBRUcsTUFBTTtnQkFDN0JGLFFBQVFDLEdBQUcsQ0FBQyx5QkFBcUNHLE9BQVpELEtBQUksVUFBWSxPQUFKQztnQkFDakRDLFVBQVVGLEtBQUtDO1lBQ2pCO1lBRUEsa0NBQWtDO1lBQ2xDbkMsSUFBSUssT0FBTyxDQUFDd0IsRUFBRSxDQUFDLFFBQVE7b0JBRXJCLDJDQUEyQztnQkFDM0M3QjtnQkFGQStCLFFBQVFDLEdBQUcsQ0FBQztpQkFFWmhDLGVBQUFBLElBQUlLLE9BQU8sY0FBWEwsbUNBQUFBLGFBQWFxQyxhQUFhLENBQUM7b0JBQ3pCMUIsTUFBTTtnQkFDUjtnQkFDQW9CLFFBQVFDLEdBQUcsQ0FBQztZQUNkO1lBRUEsb0NBQW9DO1lBQ3BDaEMsSUFBSUssT0FBTyxDQUFDd0IsRUFBRSxDQUFDLGNBQWM7Z0JBQzNCRSxRQUFRQyxHQUFHLENBQUM7WUFDZDtRQUNGO1FBRUEscUJBQXFCO1FBQ3JCLE9BQU87WUFDTC9CLFdBQVdJLE9BQU8sQ0FBQ2lDLE9BQU8sQ0FBQ0MsQ0FBQUEsU0FBVUEsT0FBT0MsTUFBTTtZQUNsRCxJQUFJeEMsSUFBSUssT0FBTyxFQUFFO2dCQUNmTCxJQUFJSyxPQUFPLENBQUNtQyxNQUFNO2dCQUNsQnhDLElBQUlLLE9BQU8sR0FBRztZQUNoQjtRQUNGO0lBQ0YsR0FBRyxFQUFFO0lBRUwsd0RBQXdEO0lBQ3hELE1BQU0rQixZQUFZLENBQUNGLEtBQWFDO1FBQzlCLElBQUksQ0FBQ25DLElBQUlLLE9BQU8sRUFBRTtRQUVsQjBCLFFBQVFDLEdBQUcsQ0FBQyxxQkFBcUI7WUFBQ0U7WUFBS0M7U0FBSTtRQUUzQyxxREFBcUQ7UUFDckQscURBQXFEO1FBQ3JELElBQUlsQyxXQUFXSSxPQUFPLENBQUNvQyxNQUFNLElBQUksR0FBRztZQUNsQyxNQUFNQyxZQUFZekMsV0FBV0ksT0FBTyxDQUFDc0MsS0FBSztZQUMxQ0Qsc0JBQUFBLGdDQUFBQSxVQUFXRixNQUFNO1lBQ2pCdEMsVUFBVUcsT0FBTyxDQUFDc0MsS0FBSztRQUN6QjtRQUVBLG1FQUFtRTtRQUNuRSxNQUFNQyxnQkFBZ0IzQyxXQUFXSSxPQUFPLENBQUNvQyxNQUFNLEtBQUs7UUFDcEQsTUFBTUksY0FBY0QsZ0JBQWdCLFlBQVksVUFBVSxpQ0FBaUM7O1FBRTNGLHdCQUF3QjtRQUN4QixNQUFNRSxLQUFLQyxTQUFTQyxhQUFhLENBQUM7UUFDbENGLEdBQUdHLFNBQVMsR0FBRztRQUNmSCxHQUFHdEMsS0FBSyxDQUFDMEMsZUFBZSxHQUFHTDtRQUUzQmQsUUFBUUMsR0FBRyxDQUFDLFVBQTBELE9BQWhEWSxnQkFBZ0IsZ0JBQWdCLGlCQUFnQjtRQUV0RSw0QkFBNEI7UUFDNUIsTUFBTUwsU0FBUyxJQUFJN0MsMkRBQWlCLENBQUM7WUFDbkMwRCxTQUFTTjtZQUNUTyxRQUFRO1FBQ1YsR0FDR0MsU0FBUyxDQUFDO1lBQUNwQjtZQUFLQztTQUFJLEVBQ3BCb0IsS0FBSyxDQUFDdkQsSUFBSUssT0FBTztRQUVwQixrQkFBa0I7UUFDbEJKLFdBQVdJLE9BQU8sQ0FBQ21ELElBQUksQ0FBQ2pCO1FBQ3hCckMsVUFBVUcsT0FBTyxDQUFDbUQsSUFBSSxDQUFDO1lBQUNyQjtZQUFLRDtTQUFJO1FBRWpDSCxRQUFRQyxHQUFHLENBQUMsMEJBQTBCL0IsV0FBV0ksT0FBTyxDQUFDb0MsTUFBTTtRQUMvRFYsUUFBUUMsR0FBRyxDQUFDLG1CQUFtQjlCLFVBQVVHLE9BQU87UUFFaEQsa0RBQWtEO1FBQ2xELElBQUlKLFdBQVdJLE9BQU8sQ0FBQ29DLE1BQU0sS0FBSyxHQUFHO1lBQ25DVixRQUFRQyxHQUFHLENBQUM7WUFDWnlCLDBCQUEwQnZELFVBQVVHLE9BQU87UUFDN0MsT0FBTztZQUNMLGtDQUFrQztZQUNsQyxJQUFJTCxJQUFJSyxPQUFPLENBQUNxRCxTQUFTLENBQUMsVUFBVTtnQkFDbEMsSUFBSTtvQkFDRjFELElBQUlLLE9BQU8sQ0FBQ3NELFdBQVcsQ0FBQztvQkFDeEIzRCxJQUFJSyxPQUFPLENBQUNzRCxXQUFXLENBQUM7b0JBQ3hCM0QsSUFBSUssT0FBTyxDQUFDdUQsWUFBWSxDQUFDO2dCQUMzQixFQUFFLE9BQU85QixHQUFHO29CQUNWQyxRQUFROEIsS0FBSyxDQUFDLG1DQUFtQy9CO2dCQUNuRDtZQUNGO1FBQ0Y7SUFDRjtJQUVBLHFEQUFxRDtJQUNyRCxNQUFNMkIsNEJBQTRCLENBQUNLO1FBQ2pDLElBQUksQ0FBQzlELElBQUlLLE9BQU8sSUFBSXlELFlBQVlyQixNQUFNLEtBQUssR0FBRztRQUU5QyxxREFBcUQ7UUFDckQsTUFBTSxDQUFDc0IsTUFBTUMsS0FBSyxHQUFHRixXQUFXLENBQUMsRUFBRTtRQUNuQyxNQUFNLENBQUNHLE1BQU1DLEtBQUssR0FBR0osV0FBVyxDQUFDLEVBQUU7UUFFbkMvQixRQUFRQyxHQUFHLENBQUMsa0NBQ1YsWUFBcUJnQyxPQUFURCxNQUFLLE1BQVMsT0FBTEMsT0FDckIsWUFBcUJFLE9BQVRELE1BQUssTUFBUyxPQUFMQztRQUd2QixNQUFNQyxPQUFPeEUsbUZBQTRCQSxDQUFDb0UsTUFBTUMsTUFBTUMsTUFBTUM7UUFDNUQsTUFBTUUsV0FBV3ZFLG1GQUE0QkEsQ0FBQ2tFLE1BQU1DLE1BQU1DLE1BQU1DO1FBRWhFbkMsUUFBUUMsR0FBRyxDQUFDLHNCQUFzQjtZQUFFbUM7WUFBTUM7UUFBUztRQUVuRCx1QkFBdUI7UUFDdkIsTUFBTUMsZ0JBQWdCekUscUVBQWNBLENBQUN1RTtRQUNyQy9ELFlBQVlpRTtRQUVaLGtDQUFrQztRQUNsQyxJQUFJckUsSUFBSUssT0FBTyxDQUFDcUQsU0FBUyxDQUFDLFVBQVU7WUFDbEMsSUFBSTtnQkFDRjFELElBQUlLLE9BQU8sQ0FBQ3NELFdBQVcsQ0FBQztnQkFDeEIzRCxJQUFJSyxPQUFPLENBQUNzRCxXQUFXLENBQUM7Z0JBQ3hCM0QsSUFBSUssT0FBTyxDQUFDdUQsWUFBWSxDQUFDO1lBQzNCLEVBQUUsT0FBTzlCLEdBQUc7Z0JBQ1ZDLFFBQVE4QixLQUFLLENBQUMsbUNBQW1DL0I7WUFDbkQ7UUFDRjtRQUVBLDRFQUE0RTtRQUM1RTlCLElBQUlLLE9BQU8sQ0FBQ2lFLFNBQVMsQ0FBQyxTQUFTO1lBQzdCM0QsTUFBTTtZQUNONEQsTUFBTTtnQkFDSjVELE1BQU07Z0JBQ042RCxZQUFZLENBQUM7Z0JBQ2JDLFVBQVU7b0JBQ1I5RCxNQUFNO29CQUNOK0QsYUFBYTt3QkFDWDs0QkFBQ1Y7NEJBQU1EO3lCQUFLO3dCQUNaOzRCQUFDRzs0QkFBTUQ7eUJBQUs7cUJBQ2I7Z0JBQ0g7WUFDRjtRQUNGO1FBRUFsQyxRQUFRQyxHQUFHLENBQUMsd0NBQXdDO1lBQ2xEO2dCQUFDZ0M7Z0JBQU1EO2FBQUs7WUFDWjtnQkFBQ0c7Z0JBQU1EO2FBQUs7U0FDYjtRQUVELDJCQUEyQjtRQUMzQmpFLElBQUlLLE9BQU8sQ0FBQ3NFLFFBQVEsQ0FBQztZQUNuQjNELElBQUk7WUFDSkwsTUFBTTtZQUNOTSxRQUFRO1lBQ1IyRCxRQUFRO2dCQUNOLGFBQWE7Z0JBQ2IsWUFBWTtZQUNkO1lBQ0FDLE9BQU87Z0JBQ0wsY0FBYztnQkFDZCxjQUFjO2dCQUNkLGdCQUFnQjtnQkFDaEIsYUFBYTtZQUNmO1FBQ0Y7UUFFQTlDLFFBQVFDLEdBQUcsQ0FBQztRQUVaLGlDQUFpQztRQUNqQ2hDLElBQUlLLE9BQU8sQ0FBQ3NFLFFBQVEsQ0FBQztZQUNuQjNELElBQUk7WUFDSkwsTUFBTTtZQUNOTSxRQUFRO1lBQ1IyRCxRQUFRO2dCQUNOLGFBQWE7Z0JBQ2IsWUFBWTtZQUNkO1lBQ0FDLE9BQU87Z0JBQ0wsY0FBYztnQkFDZCxjQUFjO2dCQUNkLGdCQUFnQjtnQkFDaEIsa0JBQWtCO29CQUFDO29CQUFLO2lCQUFFO1lBQzVCO1FBQ0Y7UUFFQTlDLFFBQVFDLEdBQUcsQ0FBQztRQUVaLCtCQUErQjtRQUMvQixNQUFNOEMsU0FBUyxDQUFDZixPQUFPRSxJQUFHLElBQUs7UUFDL0IsTUFBTWMsU0FBUyxDQUFDZixPQUFPRSxJQUFHLElBQUs7UUFFL0IseUJBQXlCO1FBQ3pCLE1BQU1jLGlCQUFpQmpDLFNBQVNrQyxzQkFBc0IsQ0FBQztRQUN2REMsTUFBTUMsSUFBSSxDQUFDSCxnQkFBZ0IxQyxPQUFPLENBQUM4QyxDQUFBQSxRQUFTQSxNQUFNNUMsTUFBTTtRQUV4RCwwQkFBMEI7UUFDMUIsSUFBSTlDLDBEQUFnQixDQUFDO1lBQ25CNEYsYUFBYTtZQUNiQyxjQUFjO1lBQ2R0QyxXQUFXO1lBQ1hJLFFBQVE7UUFDVixHQUNHQyxTQUFTLENBQUM7WUFBQ3lCO1lBQVFEO1NBQU8sRUFDMUJVLE9BQU8sQ0FBQyxtR0FHNEJwQixPQURjQyxlQUFjLHFEQUNSLE9BQXBCRCxTQUFTcUIsT0FBTyxDQUFDLElBQUcsc0NBR3hEbEMsS0FBSyxDQUFDdkQsSUFBSUssT0FBTztRQUVwQjBCLFFBQVFDLEdBQUcsQ0FBQywrQkFBK0JxQztJQUM3QztJQUVBLHFCQUNFOzswQkFDRSw4REFBQ3FCO2dCQUFJekMsV0FBVTs7a0NBQ2IsOERBQUMwQzt3QkFBRzFDLFdBQVU7a0NBQXlCOzs7Ozs7a0NBQ3ZDLDhEQUFDMkM7a0NBQUU7Ozs7OztrQ0FFSCw4REFBQ0Y7d0JBQUl6QyxXQUFVOzswQ0FDYiw4REFBQzRDOzBDQUFLOzs7Ozs7MENBQ04sOERBQUNBO2dDQUFLNUMsV0FBVTswQ0FBbUM5Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQUl2RCw4REFBQ3VGO2dCQUNDSSxLQUFLL0Y7Z0JBQ0xrRCxXQUFVO2dCQUNWekMsT0FBTztvQkFBRXVGLE9BQU87b0JBQVFDLFFBQVE7Z0JBQVE7Ozs7Ozs7O0FBSWhEO0dBMVJ3QmxHO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvTWFwR2xvYmUudHN4PzBmZjciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IG1hcGxpYnJlZ2wgZnJvbSAnbWFwbGlicmUtZ2wnXG5pbXBvcnQgeyBjYWxjdWxhdGVUaGVvcmV0aWNhbFBpbmdUaW1lLCBmb3JtYXRQaW5nVGltZSwgY2FsY3VsYXRlR3JlYXRDaXJjbGVEaXN0YW5jZSB9IGZyb20gJ0AvdXRpbHMvcGluZ0NhbGN1bGF0b3InXG5pbXBvcnQgJ21hcGxpYnJlLWdsL2Rpc3QvbWFwbGlicmUtZ2wuY3NzJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNYXBHbG9iZSgpIHtcbiAgY29uc3QgbWFwQ29udGFpbmVyID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKVxuICBjb25zdCBtYXAgPSB1c2VSZWY8bWFwbGlicmVnbC5NYXAgfCBudWxsPihudWxsKVxuICBjb25zdCBtYXJrZXJzUmVmID0gdXNlUmVmPG1hcGxpYnJlZ2wuTWFya2VyW10+KFtdKVxuICBjb25zdCBwb2ludHNSZWYgPSB1c2VSZWY8QXJyYXk8W251bWJlciwgbnVtYmVyXT4+KFtdKVxuICBjb25zdCBbcGluZ1RpbWUsIHNldFBpbmdUaW1lXSA9IHVzZVN0YXRlPHN0cmluZz4oJ04vQScpXG4gIFxuICAvLyBJbml0aWFsaXplIG1hcFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtYXAuY3VycmVudCkgcmV0dXJuIC8vIE9ubHkgaW5pdGlhbGl6ZSBvbmNlXG4gICAgXG4gICAgaWYgKG1hcENvbnRhaW5lci5jdXJyZW50KSB7XG4gICAgICAvLyBDcmVhdGUgdGhlIG1hcCB3aXRoIGEgc3RhbmRhcmQgc3R5bGVcbiAgICAgIG1hcC5jdXJyZW50ID0gbmV3IG1hcGxpYnJlZ2wuTWFwKHtcbiAgICAgICAgY29udGFpbmVyOiBtYXBDb250YWluZXIuY3VycmVudCxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICB2ZXJzaW9uOiA4LFxuICAgICAgICAgIHNvdXJjZXM6IHtcbiAgICAgICAgICAgICdyYXN0ZXItdGlsZXMnOiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdyYXN0ZXInLFxuICAgICAgICAgICAgICB0aWxlczogWydodHRwczovL3RpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nJ10sXG4gICAgICAgICAgICAgIHRpbGVTaXplOiAyNTYsXG4gICAgICAgICAgICAgIGF0dHJpYnV0aW9uOiAnwqkgT3BlblN0cmVldE1hcCBjb250cmlidXRvcnMnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBsYXllcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWQ6ICdzaW1wbGUtdGlsZXMnLFxuICAgICAgICAgICAgICB0eXBlOiAncmFzdGVyJyxcbiAgICAgICAgICAgICAgc291cmNlOiAncmFzdGVyLXRpbGVzJyxcbiAgICAgICAgICAgICAgbWluem9vbTogMCxcbiAgICAgICAgICAgICAgbWF4em9vbTogMTlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIGNlbnRlcjogWzAsIDBdLFxuICAgICAgICB6b29tOiAxLFxuICAgICAgICBwaXRjaDogMCxcbiAgICAgICAgYmVhcmluZzogMFxuICAgICAgfSlcbiAgICAgIFxuICAgICAgLy8gU2V0IGRhcmsgYmFja2dyb3VuZCBmb3IgdGhlIG1hcFxuICAgICAgbWFwQ29udGFpbmVyLmN1cnJlbnQuc3R5bGUuYmFja2dyb3VuZCA9ICcjMDAwJ1xuICAgICAgXG4gICAgICAvLyBBZGQgbmF2aWdhdGlvbiBjb250cm9sXG4gICAgICBtYXAuY3VycmVudC5hZGRDb250cm9sKG5ldyBtYXBsaWJyZWdsLk5hdmlnYXRpb25Db250cm9sKCkpXG4gICAgICBcbiAgICAgIC8vIEFkZCBhdHRyaWJ1dGlvblxuICAgICAgbWFwLmN1cnJlbnQuYWRkQ29udHJvbChuZXcgbWFwbGlicmVnbC5BdHRyaWJ1dGlvbkNvbnRyb2woe1xuICAgICAgICBjdXN0b21BdHRyaWJ1dGlvbjogJ8KpIE9wZW5TdHJlZXRNYXAgY29udHJpYnV0b3JzJ1xuICAgICAgfSksICdib3R0b20tcmlnaHQnKVxuICAgICAgXG4gICAgICAvLyBBZGQgY2xpY2sgaGFuZGxlciBmb3IgYWRkaW5nIG1hcmtlcnNcbiAgICAgIG1hcC5jdXJyZW50Lm9uKCdjbGljaycsIChlKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdNYXAgY2xpY2tlZCBhdDonLCBlLmxuZ0xhdClcbiAgICAgICAgY29uc3QgeyBsbmcsIGxhdCB9ID0gZS5sbmdMYXRcbiAgICAgICAgY29uc29sZS5sb2coYEFkZGluZyBtYXJrZXIgYXQ6IGxuZz0ke2xuZ30sIGxhdD0ke2xhdH1gKVxuICAgICAgICBhZGRNYXJrZXIobG5nLCBsYXQpXG4gICAgICB9KVxuICAgICAgXG4gICAgICAvLyBBZGQgZGVidWcgbGlzdGVuZXIgZm9yIG1hcCBsb2FkXG4gICAgICBtYXAuY3VycmVudC5vbignbG9hZCcsICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ01hcCBsb2FkZWQnKVxuICAgICAgICAvLyBTZXQgZ2xvYmUgcHJvamVjdGlvbiBhZnRlciBtYXAgaXMgbG9hZGVkXG4gICAgICAgIG1hcC5jdXJyZW50Py5zZXRQcm9qZWN0aW9uKHtcbiAgICAgICAgICB0eXBlOiAnZ2xvYmUnXG4gICAgICAgIH0pXG4gICAgICAgIGNvbnNvbGUubG9nKCdHbG9iZSBwcm9qZWN0aW9uIHNldCcpXG4gICAgICB9KVxuICAgICAgXG4gICAgICAvLyBBZGQgZGVidWcgbGlzdGVuZXIgZm9yIHN0eWxlIGxvYWRcbiAgICAgIG1hcC5jdXJyZW50Lm9uKCdzdHlsZS5sb2FkJywgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnTWFwIHN0eWxlIGxvYWRlZCcpXG4gICAgICB9KVxuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhbnVwIG9uIHVubW91bnRcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbWFya2Vyc1JlZi5jdXJyZW50LmZvckVhY2gobWFya2VyID0+IG1hcmtlci5yZW1vdmUoKSlcbiAgICAgIGlmIChtYXAuY3VycmVudCkge1xuICAgICAgICBtYXAuY3VycmVudC5yZW1vdmUoKVxuICAgICAgICBtYXAuY3VycmVudCA9IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKVxuICBcbiAgLy8gRnVuY3Rpb24gdG8gYWRkIGEgbWFya2VyIGF0IHRoZSBzcGVjaWZpZWQgY29vcmRpbmF0ZXNcbiAgY29uc3QgYWRkTWFya2VyID0gKGxuZzogbnVtYmVyLCBsYXQ6IG51bWJlcikgPT4ge1xuICAgIGlmICghbWFwLmN1cnJlbnQpIHJldHVyblxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgbWFya2VyIGF0OicsIFtsbmcsIGxhdF0pXG4gICAgXG4gICAgLy8gTWFuYWdlIG1hcmtlcnMgZGlyZWN0bHkgd2l0aCByZWZzIGluc3RlYWQgb2Ygc3RhdGVcbiAgICAvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgMiBtYXJrZXJzLCByZW1vdmUgdGhlIGZpcnN0IG9uZVxuICAgIGlmIChtYXJrZXJzUmVmLmN1cnJlbnQubGVuZ3RoID49IDIpIHtcbiAgICAgIGNvbnN0IG9sZE1hcmtlciA9IG1hcmtlcnNSZWYuY3VycmVudC5zaGlmdCgpXG4gICAgICBvbGRNYXJrZXI/LnJlbW92ZSgpXG4gICAgICBwb2ludHNSZWYuY3VycmVudC5zaGlmdCgpXG4gICAgfVxuICAgIFxuICAgIC8vIERldGVybWluZSBpZiB0aGlzIHdpbGwgYmUgdGhlIGZpcnN0IG9yIHNlY29uZCBtYXJrZXIgaW4gdGhlIHBhaXJcbiAgICBjb25zdCBpc0ZpcnN0SW5QYWlyID0gbWFya2Vyc1JlZi5jdXJyZW50Lmxlbmd0aCA9PT0gMFxuICAgIGNvbnN0IG1hcmtlckNvbG9yID0gaXNGaXJzdEluUGFpciA/ICcjZmYzYjMwJyA6ICcjMDA3YWZmJyAvLyBSZWQgZm9yIGZpcnN0LCBibHVlIGZvciBzZWNvbmRcbiAgICBcbiAgICAvLyBDcmVhdGUgbWFya2VyIGVsZW1lbnRcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgZWwuY2xhc3NOYW1lID0gJ21hcmtlcidcbiAgICBlbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBtYXJrZXJDb2xvclxuICAgIFxuICAgIGNvbnNvbGUubG9nKGBBZGRpbmcgJHtpc0ZpcnN0SW5QYWlyID8gJ2ZpcnN0IChyZWQpJyA6ICdzZWNvbmQgKGJsdWUpJ30gbWFya2VyIGluIHBhaXJgKVxuICAgIFxuICAgIC8vIENyZWF0ZSBhbmQgYWRkIHRoZSBtYXJrZXJcbiAgICBjb25zdCBtYXJrZXIgPSBuZXcgbWFwbGlicmVnbC5NYXJrZXIoe1xuICAgICAgZWxlbWVudDogZWwsXG4gICAgICBhbmNob3I6ICdjZW50ZXInXG4gICAgfSlcbiAgICAgIC5zZXRMbmdMYXQoW2xuZywgbGF0XSlcbiAgICAgIC5hZGRUbyhtYXAuY3VycmVudClcbiAgICBcbiAgICAvLyBBZGQgdG8gb3VyIHJlZnNcbiAgICBtYXJrZXJzUmVmLmN1cnJlbnQucHVzaChtYXJrZXIpXG4gICAgcG9pbnRzUmVmLmN1cnJlbnQucHVzaChbbGF0LCBsbmddIGFzIFtudW1iZXIsIG51bWJlcl0pXG4gICAgXG4gICAgY29uc29sZS5sb2coJ0N1cnJlbnQgbWFya2VycyBjb3VudDonLCBtYXJrZXJzUmVmLmN1cnJlbnQubGVuZ3RoKVxuICAgIGNvbnNvbGUubG9nKCdDdXJyZW50IHBvaW50czonLCBwb2ludHNSZWYuY3VycmVudClcbiAgICBcbiAgICAvLyBEcmF3IGxpbmUgYmV0d2VlbiBwb2ludHMgaWYgd2UgaGF2ZSBleGFjdGx5IHR3b1xuICAgIGlmIChtYXJrZXJzUmVmLmN1cnJlbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zb2xlLmxvZygnV2UgaGF2ZSAyIG1hcmtlcnMsIGRyYXdpbmcgbGluZSBhbmQgY2FsY3VsYXRpbmcgcGluZycpXG4gICAgICBkcmF3Um91dGVBbmRDYWxjdWxhdGVQaW5nKHBvaW50c1JlZi5jdXJyZW50KVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1vdmUgZXhpc3RpbmcgbGluZSBpZiBwcmVzZW50XG4gICAgICBpZiAobWFwLmN1cnJlbnQuZ2V0U291cmNlKCdyb3V0ZScpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbWFwLmN1cnJlbnQucmVtb3ZlTGF5ZXIoJ3JvdXRlLWxpbmUnKVxuICAgICAgICAgIG1hcC5jdXJyZW50LnJlbW92ZUxheWVyKCdyb3V0ZS1nbG93JylcbiAgICAgICAgICBtYXAuY3VycmVudC5yZW1vdmVTb3VyY2UoJ3JvdXRlJylcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIGV4aXN0aW5nIGxheWVyczonLCBlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICAvLyBTZXBhcmF0ZSBmdW5jdGlvbiB0byBkcmF3IHJvdXRlIGFuZCBjYWxjdWxhdGUgcGluZ1xuICBjb25zdCBkcmF3Um91dGVBbmRDYWxjdWxhdGVQaW5nID0gKHJvdXRlUG9pbnRzOiBbbnVtYmVyLCBudW1iZXJdW10pID0+IHtcbiAgICBpZiAoIW1hcC5jdXJyZW50IHx8IHJvdXRlUG9pbnRzLmxlbmd0aCAhPT0gMikgcmV0dXJuXG4gICAgXG4gICAgLy8gR2V0IGNvb3JkaW5hdGVzIGluIGNvcnJlY3QgZm9ybWF0IGZvciBjYWxjdWxhdGlvbnNcbiAgICBjb25zdCBbbGF0MSwgbG5nMV0gPSByb3V0ZVBvaW50c1swXVxuICAgIGNvbnN0IFtsYXQyLCBsbmcyXSA9IHJvdXRlUG9pbnRzWzFdXG4gICAgXG4gICAgY29uc29sZS5sb2coJ0NhbGN1bGF0aW5nIHBpbmcgdGltZSBiZXR3ZWVuOicsIFxuICAgICAgYFBvaW50IDE6ICR7bGF0MX0sICR7bG5nMX1gLFxuICAgICAgYFBvaW50IDI6ICR7bGF0Mn0sICR7bG5nMn1gXG4gICAgKVxuICAgIFxuICAgIGNvbnN0IHRpbWUgPSBjYWxjdWxhdGVUaGVvcmV0aWNhbFBpbmdUaW1lKGxhdDEsIGxuZzEsIGxhdDIsIGxuZzIpXG4gICAgY29uc3QgZGlzdGFuY2UgPSBjYWxjdWxhdGVHcmVhdENpcmNsZURpc3RhbmNlKGxhdDEsIGxuZzEsIGxhdDIsIGxuZzIpXG4gICAgXG4gICAgY29uc29sZS5sb2coJ0NhbGN1bGF0ZWQgdmFsdWVzOicsIHsgdGltZSwgZGlzdGFuY2UgfSlcbiAgICBcbiAgICAvLyBGb3JtYXQgdGhlIHBpbmcgdGltZVxuICAgIGNvbnN0IGZvcm1hdHRlZFRpbWUgPSBmb3JtYXRQaW5nVGltZSh0aW1lKVxuICAgIHNldFBpbmdUaW1lKGZvcm1hdHRlZFRpbWUpXG4gICAgXG4gICAgLy8gUmVtb3ZlIGV4aXN0aW5nIGxpbmUgaWYgcHJlc2VudFxuICAgIGlmIChtYXAuY3VycmVudC5nZXRTb3VyY2UoJ3JvdXRlJykpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1hcC5jdXJyZW50LnJlbW92ZUxheWVyKCdyb3V0ZS1saW5lJylcbiAgICAgICAgbWFwLmN1cnJlbnQucmVtb3ZlTGF5ZXIoJ3JvdXRlLWdsb3cnKVxuICAgICAgICBtYXAuY3VycmVudC5yZW1vdmVTb3VyY2UoJ3JvdXRlJylcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVtb3ZpbmcgZXhpc3RpbmcgbGF5ZXJzOicsIGUpXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCB0aGUgbmV3IGxpbmUgc291cmNlIHdpdGggY29vcmRpbmF0ZXMgaW4gW2xuZywgbGF0XSBmb3JtYXQgZm9yIEdlb0pTT05cbiAgICBtYXAuY3VycmVudC5hZGRTb3VyY2UoJ3JvdXRlJywge1xuICAgICAgdHlwZTogJ2dlb2pzb24nLFxuICAgICAgZGF0YToge1xuICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgIHR5cGU6ICdMaW5lU3RyaW5nJyxcbiAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgW2xuZzEsIGxhdDFdLCAvLyBHZW9KU09OIHVzZXMgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdIG9yZGVyXG4gICAgICAgICAgICBbbG5nMiwgbGF0Ml1cbiAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdBZGRlZCByb3V0ZSBzb3VyY2Ugd2l0aCBjb29yZGluYXRlczonLCBbXG4gICAgICBbbG5nMSwgbGF0MV0sXG4gICAgICBbbG5nMiwgbGF0Ml1cbiAgICBdKVxuICAgIFxuICAgIC8vIEFkZCB0aGUgZ2xvdyBsYXllciBmaXJzdFxuICAgIG1hcC5jdXJyZW50LmFkZExheWVyKHtcbiAgICAgIGlkOiAncm91dGUtZ2xvdycsXG4gICAgICB0eXBlOiAnbGluZScsXG4gICAgICBzb3VyY2U6ICdyb3V0ZScsXG4gICAgICBsYXlvdXQ6IHtcbiAgICAgICAgJ2xpbmUtam9pbic6ICdyb3VuZCcsXG4gICAgICAgICdsaW5lLWNhcCc6ICdyb3VuZCdcbiAgICAgIH0sXG4gICAgICBwYWludDoge1xuICAgICAgICAnbGluZS1jb2xvcic6ICcjNGRiOGZmJyxcbiAgICAgICAgJ2xpbmUtd2lkdGgnOiAxNSxcbiAgICAgICAgJ2xpbmUtb3BhY2l0eSc6IDAuOCxcbiAgICAgICAgJ2xpbmUtYmx1cic6IDE1XG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgICBjb25zb2xlLmxvZygnQWRkZWQgZ2xvdyBsYXllcicpXG4gICAgXG4gICAgLy8gQWRkIHRoZSBtYWluIGxpbmUgbGF5ZXIgb24gdG9wXG4gICAgbWFwLmN1cnJlbnQuYWRkTGF5ZXIoe1xuICAgICAgaWQ6ICdyb3V0ZS1saW5lJyxcbiAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgIHNvdXJjZTogJ3JvdXRlJyxcbiAgICAgIGxheW91dDoge1xuICAgICAgICAnbGluZS1qb2luJzogJ3JvdW5kJyxcbiAgICAgICAgJ2xpbmUtY2FwJzogJ3JvdW5kJ1xuICAgICAgfSxcbiAgICAgIHBhaW50OiB7XG4gICAgICAgICdsaW5lLWNvbG9yJzogJyNmZmZmZmYnLFxuICAgICAgICAnbGluZS13aWR0aCc6IDUsXG4gICAgICAgICdsaW5lLW9wYWNpdHknOiAxLFxuICAgICAgICAnbGluZS1kYXNoYXJyYXknOiBbMC41LCAxXVxuICAgICAgfVxuICAgIH0pXG4gICAgXG4gICAgY29uc29sZS5sb2coJ0FkZGVkIGxpbmUgbGF5ZXInKVxuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBtaWRwb2ludCBmb3IgcG9wdXBcbiAgICBjb25zdCBtaWRMYXQgPSAobGF0MSArIGxhdDIpIC8gMlxuICAgIGNvbnN0IG1pZExuZyA9IChsbmcxICsgbG5nMikgLyAyXG4gICAgXG4gICAgLy8gUmVtb3ZlIGV4aXN0aW5nIHBvcHVwc1xuICAgIGNvbnN0IGV4aXN0aW5nUG9wdXBzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgncGluZy1wb3B1cCcpXG4gICAgQXJyYXkuZnJvbShleGlzdGluZ1BvcHVwcykuZm9yRWFjaChwb3B1cCA9PiBwb3B1cC5yZW1vdmUoKSlcbiAgICBcbiAgICAvLyBBZGQgdGhlIHBpbmcgdGltZSBwb3B1cFxuICAgIG5ldyBtYXBsaWJyZWdsLlBvcHVwKHtcbiAgICAgIGNsb3NlQnV0dG9uOiBmYWxzZSxcbiAgICAgIGNsb3NlT25DbGljazogZmFsc2UsXG4gICAgICBjbGFzc05hbWU6ICdwaW5nLXBvcHVwJyxcbiAgICAgIGFuY2hvcjogJ2NlbnRlcidcbiAgICB9KVxuICAgICAgLnNldExuZ0xhdChbbWlkTG5nLCBtaWRMYXRdKVxuICAgICAgLnNldEhUTUwoYFxuICAgICAgICA8ZGl2IGNsYXNzPVwidGV4dC1jZW50ZXIgcC0yXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImZvbnQtYm9sZCB0ZXh0LWxnIHRleHQtYmx1ZS00MDBcIj4ke2Zvcm1hdHRlZFRpbWV9PC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInRleHQtc21cIj5EaXN0YW5jZTogJHtkaXN0YW5jZS50b0ZpeGVkKDApfSBrbTwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIGApXG4gICAgICAuYWRkVG8obWFwLmN1cnJlbnQpXG4gICAgXG4gICAgY29uc29sZS5sb2coJ0FkZGVkIHBvcHVwIHdpdGggcGluZyB0aW1lOicsIGZvcm1hdHRlZFRpbWUpXG4gIH1cbiAgXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5zdHJ1Y3Rpb25zIGFic29sdXRlIHRvcC00IGxlZnQtNCB6LTEwIGJnLWJsYWNrLzcwIHAtNCByb3VuZGVkLWxnIHRleHQtd2hpdGUgbWF4LXctbWRcIj5cbiAgICAgICAgPGgzIGNsYXNzTmFtZT1cInRleHQteGwgZm9udC1ib2xkIG1iLTJcIj5JbnN0cnVjdGlvbnM6PC9oMz5cbiAgICAgICAgPHA+Q2xpY2sgb24gdHdvIGRpZmZlcmVudCBsb2NhdGlvbnMgb24gdGhlIGdsb2JlIHRvIGNhbGN1bGF0ZSB0aGUgdGhlb3JldGljYWwgbWluaW11bSBwaW5nIHRpbWUgYmV0d2VlbiB0aGVtLjwvcD5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtNCBwLTIgYmctZ3JheS04MDAgcm91bmRlZFwiPlxuICAgICAgICAgIDxzcGFuPlRoZW9yZXRpY2FsIE1pbmltdW0gUGluZyBUaW1lOiA8L3NwYW4+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZm9udC1ib2xkIHRleHQteGwgdGV4dC1ibHVlLTQwMFwiPntwaW5nVGltZX08L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICBcbiAgICAgIDxkaXYgXG4gICAgICAgIHJlZj17bWFwQ29udGFpbmVyfSBcbiAgICAgICAgY2xhc3NOYW1lPVwibWFwLWNvbnRhaW5lclwiIFxuICAgICAgICBzdHlsZT17eyB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICcxMDB2aCcgfX0gXG4gICAgICAvPlxuICAgIDwvPlxuICApXG59ICJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsIm1hcGxpYnJlZ2wiLCJjYWxjdWxhdGVUaGVvcmV0aWNhbFBpbmdUaW1lIiwiZm9ybWF0UGluZ1RpbWUiLCJjYWxjdWxhdGVHcmVhdENpcmNsZURpc3RhbmNlIiwiTWFwR2xvYmUiLCJtYXBDb250YWluZXIiLCJtYXAiLCJtYXJrZXJzUmVmIiwicG9pbnRzUmVmIiwicGluZ1RpbWUiLCJzZXRQaW5nVGltZSIsImN1cnJlbnQiLCJNYXAiLCJjb250YWluZXIiLCJzdHlsZSIsInZlcnNpb24iLCJzb3VyY2VzIiwidHlwZSIsInRpbGVzIiwidGlsZVNpemUiLCJhdHRyaWJ1dGlvbiIsImxheWVycyIsImlkIiwic291cmNlIiwibWluem9vbSIsIm1heHpvb20iLCJjZW50ZXIiLCJ6b29tIiwicGl0Y2giLCJiZWFyaW5nIiwiYmFja2dyb3VuZCIsImFkZENvbnRyb2wiLCJOYXZpZ2F0aW9uQ29udHJvbCIsIkF0dHJpYnV0aW9uQ29udHJvbCIsImN1c3RvbUF0dHJpYnV0aW9uIiwib24iLCJlIiwiY29uc29sZSIsImxvZyIsImxuZ0xhdCIsImxuZyIsImxhdCIsImFkZE1hcmtlciIsInNldFByb2plY3Rpb24iLCJmb3JFYWNoIiwibWFya2VyIiwicmVtb3ZlIiwibGVuZ3RoIiwib2xkTWFya2VyIiwic2hpZnQiLCJpc0ZpcnN0SW5QYWlyIiwibWFya2VyQ29sb3IiLCJlbCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsImJhY2tncm91bmRDb2xvciIsIk1hcmtlciIsImVsZW1lbnQiLCJhbmNob3IiLCJzZXRMbmdMYXQiLCJhZGRUbyIsInB1c2giLCJkcmF3Um91dGVBbmRDYWxjdWxhdGVQaW5nIiwiZ2V0U291cmNlIiwicmVtb3ZlTGF5ZXIiLCJyZW1vdmVTb3VyY2UiLCJlcnJvciIsInJvdXRlUG9pbnRzIiwibGF0MSIsImxuZzEiLCJsYXQyIiwibG5nMiIsInRpbWUiLCJkaXN0YW5jZSIsImZvcm1hdHRlZFRpbWUiLCJhZGRTb3VyY2UiLCJkYXRhIiwicHJvcGVydGllcyIsImdlb21ldHJ5IiwiY29vcmRpbmF0ZXMiLCJhZGRMYXllciIsImxheW91dCIsInBhaW50IiwibWlkTGF0IiwibWlkTG5nIiwiZXhpc3RpbmdQb3B1cHMiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwiQXJyYXkiLCJmcm9tIiwicG9wdXAiLCJQb3B1cCIsImNsb3NlQnV0dG9uIiwiY2xvc2VPbkNsaWNrIiwic2V0SFRNTCIsInRvRml4ZWQiLCJkaXYiLCJoMyIsInAiLCJzcGFuIiwicmVmIiwid2lkdGgiLCJoZWlnaHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/MapGlobe.tsx\n"));

/***/ })

});