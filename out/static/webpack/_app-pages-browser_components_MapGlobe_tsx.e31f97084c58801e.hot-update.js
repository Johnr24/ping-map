"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_components_MapGlobe_tsx",{

/***/ "(app-pages-browser)/./components/MapGlobe.tsx":
/*!*********************************!*\
  !*** ./components/MapGlobe.tsx ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ MapGlobe; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var maplibre_gl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! maplibre-gl */ \"(app-pages-browser)/./node_modules/maplibre-gl/dist/maplibre-gl.js\");\n/* harmony import */ var maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(maplibre_gl__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _utils_pingCalculator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/utils/pingCalculator */ \"(app-pages-browser)/./utils/pingCalculator.ts\");\n/* harmony import */ var maplibre_gl_dist_maplibre_gl_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! maplibre-gl/dist/maplibre-gl.css */ \"(app-pages-browser)/./node_modules/maplibre-gl/dist/maplibre-gl.css\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nfunction MapGlobe() {\n    _s();\n    const mapContainer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const markersRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const pointsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const [pingTime, setPingTime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"N/A\");\n    const markerCountRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0) // Add counter for total markers placed\n    ;\n    // Initialize map\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (map.current) return; // Only initialize once\n        if (mapContainer.current) {\n            // Create the map with a standard style\n            map.current = new (maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default().Map)({\n                container: mapContainer.current,\n                style: {\n                    version: 8,\n                    sources: {\n                        \"raster-tiles\": {\n                            type: \"raster\",\n                            tiles: [\n                                \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\"\n                            ],\n                            tileSize: 256,\n                            attribution: \"\\xa9 OpenStreetMap contributors\"\n                        }\n                    },\n                    layers: [\n                        {\n                            id: \"simple-tiles\",\n                            type: \"raster\",\n                            source: \"raster-tiles\",\n                            minzoom: 0,\n                            maxzoom: 19\n                        }\n                    ]\n                },\n                center: [\n                    0,\n                    0\n                ],\n                zoom: 1,\n                pitch: 0,\n                bearing: 0\n            });\n            // Set dark background for the map\n            mapContainer.current.style.background = \"#000\";\n            // Add navigation control\n            map.current.addControl(new (maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default().NavigationControl)());\n            // Add attribution\n            map.current.addControl(new (maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default().AttributionControl)({\n                customAttribution: \"\\xa9 OpenStreetMap contributors\"\n            }), \"bottom-right\");\n            // Add click handler for adding markers\n            map.current.on(\"click\", (e)=>{\n                console.log(\"Map clicked at:\", e.lngLat);\n                const { lng, lat } = e.lngLat;\n                console.log(\"Adding marker at: lng=\".concat(lng, \", lat=\").concat(lat));\n                addMarker(lng, lat);\n            });\n            // Add debug listener for map load\n            map.current.on(\"load\", ()=>{\n                var // Set globe projection after map is loaded\n                _map_current;\n                console.log(\"Map loaded\");\n                (_map_current = map.current) === null || _map_current === void 0 ? void 0 : _map_current.setProjection({\n                    type: \"globe\"\n                });\n                console.log(\"Globe projection set\");\n            });\n            // Add debug listener for style load\n            map.current.on(\"style.load\", ()=>{\n                console.log(\"Map style loaded\");\n            });\n        }\n        // Cleanup on unmount\n        return ()=>{\n            markersRef.current.forEach((marker)=>marker.remove());\n            if (map.current) {\n                map.current.remove();\n                map.current = null;\n            }\n        };\n    }, []);\n    // Function to add a marker at the specified coordinates\n    const addMarker = (lng, lat)=>{\n        if (!map.current) return;\n        console.log(\"Adding marker at:\", [\n            lng,\n            lat\n        ]);\n        // Manage markers directly with refs instead of state\n        // If we already have 2 markers, remove the first one\n        if (markersRef.current.length >= 2) {\n            const oldMarker = markersRef.current.shift();\n            oldMarker === null || oldMarker === void 0 ? void 0 : oldMarker.remove();\n            pointsRef.current.shift();\n        }\n        // Increment the counter each time a new marker is added\n        markerCountRef.current += 1;\n        // Determine color based on position (odd or even)\n        const markerColor = markerCountRef.current % 2 === 0 ? \"#ff3b30\" : \"#007aff\" // Red for even, blue for odd\n        ;\n        // Create marker element\n        const el = document.createElement(\"div\");\n        el.className = \"marker\";\n        el.style.backgroundColor = markerColor;\n        console.log(\"Adding \".concat(markerColor === \"#ff3b30\" ? \"red\" : \"blue\", \" marker, count: \").concat(markerCountRef.current));\n        // Create and add the marker\n        const marker = new (maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default().Marker)({\n            element: el,\n            anchor: \"center\"\n        }).setLngLat([\n            lng,\n            lat\n        ]).addTo(map.current);\n        // Add to our refs\n        markersRef.current.push(marker);\n        pointsRef.current.push([\n            lat,\n            lng\n        ]);\n        console.log(\"Current markers count:\", markersRef.current.length);\n        console.log(\"Current points:\", pointsRef.current);\n        // Draw line between points if we have exactly two\n        if (markersRef.current.length === 2) {\n            console.log(\"We have 2 markers, drawing line and calculating ping\");\n            drawRouteAndCalculatePing(pointsRef.current);\n        } else {\n            // Remove existing line if present\n            if (map.current.getSource(\"route\")) {\n                try {\n                    map.current.removeLayer(\"route-line\");\n                    map.current.removeLayer(\"route-glow\");\n                    map.current.removeSource(\"route\");\n                } catch (e) {\n                    console.error(\"Error removing existing layers:\", e);\n                }\n            }\n        }\n    };\n    // Separate function to draw route and calculate ping\n    const drawRouteAndCalculatePing = (routePoints)=>{\n        if (!map.current || routePoints.length !== 2) return;\n        // Get coordinates in correct format for calculations\n        const [lat1, lng1] = routePoints[0];\n        const [lat2, lng2] = routePoints[1];\n        console.log(\"Calculating ping time between:\", \"Point 1: \".concat(lat1, \", \").concat(lng1), \"Point 2: \".concat(lat2, \", \").concat(lng2));\n        const time = (0,_utils_pingCalculator__WEBPACK_IMPORTED_MODULE_3__.calculateTheoreticalPingTime)(lat1, lng1, lat2, lng2);\n        const distance = (0,_utils_pingCalculator__WEBPACK_IMPORTED_MODULE_3__.calculateGreatCircleDistance)(lat1, lng1, lat2, lng2);\n        console.log(\"Calculated values:\", {\n            time,\n            distance\n        });\n        // Format the ping time\n        const formattedTime = (0,_utils_pingCalculator__WEBPACK_IMPORTED_MODULE_3__.formatPingTime)(time);\n        setPingTime(formattedTime);\n        // Remove existing line if present\n        if (map.current.getSource(\"route\")) {\n            try {\n                map.current.removeLayer(\"route-line\");\n                map.current.removeLayer(\"route-glow\");\n                map.current.removeSource(\"route\");\n            } catch (e) {\n                console.error(\"Error removing existing layers:\", e);\n            }\n        }\n        // Add the new line source with coordinates in [lng, lat] format for GeoJSON\n        map.current.addSource(\"route\", {\n            type: \"geojson\",\n            data: {\n                type: \"Feature\",\n                properties: {},\n                geometry: {\n                    type: \"LineString\",\n                    coordinates: [\n                        [\n                            lng1,\n                            lat1\n                        ],\n                        [\n                            lng2,\n                            lat2\n                        ]\n                    ]\n                }\n            }\n        });\n        console.log(\"Added route source with coordinates:\", [\n            [\n                lng1,\n                lat1\n            ],\n            [\n                lng2,\n                lat2\n            ]\n        ]);\n        // Add the glow layer first\n        map.current.addLayer({\n            id: \"route-glow\",\n            type: \"line\",\n            source: \"route\",\n            layout: {\n                \"line-join\": \"round\",\n                \"line-cap\": \"round\"\n            },\n            paint: {\n                \"line-color\": \"#4db8ff\",\n                \"line-width\": 15,\n                \"line-opacity\": 0.8,\n                \"line-blur\": 15\n            }\n        });\n        console.log(\"Added glow layer\");\n        // Add the main line layer on top\n        map.current.addLayer({\n            id: \"route-line\",\n            type: \"line\",\n            source: \"route\",\n            layout: {\n                \"line-join\": \"round\",\n                \"line-cap\": \"round\"\n            },\n            paint: {\n                \"line-color\": \"#ffffff\",\n                \"line-width\": 5,\n                \"line-opacity\": 1,\n                \"line-dasharray\": [\n                    0.5,\n                    1\n                ]\n            }\n        });\n        console.log(\"Added line layer\");\n        // Calculate midpoint for popup\n        const midLat = (lat1 + lat2) / 2;\n        const midLng = (lng1 + lng2) / 2;\n        // Remove existing popups\n        const existingPopups = document.getElementsByClassName(\"ping-popup\");\n        Array.from(existingPopups).forEach((popup)=>popup.remove());\n        // Add the ping time popup\n        new (maplibre_gl__WEBPACK_IMPORTED_MODULE_2___default().Popup)({\n            closeButton: false,\n            closeOnClick: false,\n            className: \"ping-popup\",\n            anchor: \"center\"\n        }).setLngLat([\n            midLng,\n            midLat\n        ]).setHTML('\\n        <div class=\"text-center p-2\">\\n          <div class=\"font-bold text-lg text-blue-400\">'.concat(formattedTime, '</div>\\n          <div class=\"text-sm\">Distance: ').concat(distance.toFixed(0), \" km</div>\\n        </div>\\n      \")).addTo(map.current);\n        console.log(\"Added popup with ping time:\", formattedTime);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"instructions absolute top-4 left-4 z-10 bg-black/70 p-4 rounded-lg text-white max-w-md\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                        className: \"text-xl font-bold mb-2\",\n                        children: \"Instructions:\"\n                    }, void 0, false, {\n                        fileName: \"/Users/john/Documents/colour_coding/ping-map/components/MapGlobe.tsx\",\n                        lineNumber: 277,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        children: \"Click on two different locations on the globe to calculate the theoretical minimum ping time between them.\"\n                    }, void 0, false, {\n                        fileName: \"/Users/john/Documents/colour_coding/ping-map/components/MapGlobe.tsx\",\n                        lineNumber: 278,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"mt-4 p-2 bg-gray-800 rounded\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                children: \"Theoretical Minimum Ping Time: \"\n                            }, void 0, false, {\n                                fileName: \"/Users/john/Documents/colour_coding/ping-map/components/MapGlobe.tsx\",\n                                lineNumber: 281,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"font-bold text-xl text-blue-400\",\n                                children: pingTime\n                            }, void 0, false, {\n                                fileName: \"/Users/john/Documents/colour_coding/ping-map/components/MapGlobe.tsx\",\n                                lineNumber: 282,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/john/Documents/colour_coding/ping-map/components/MapGlobe.tsx\",\n                        lineNumber: 280,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/john/Documents/colour_coding/ping-map/components/MapGlobe.tsx\",\n                lineNumber: 276,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: mapContainer,\n                className: \"map-container\",\n                style: {\n                    width: \"100%\",\n                    height: \"100vh\"\n                }\n            }, void 0, false, {\n                fileName: \"/Users/john/Documents/colour_coding/ping-map/components/MapGlobe.tsx\",\n                lineNumber: 286,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}\n_s(MapGlobe, \"RNPoFIwv5X6ZOBzxWaNDozkexOk=\");\n_c = MapGlobe;\nvar _c;\n$RefreshReg$(_c, \"MapGlobe\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvTWFwR2xvYmUudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFFbUQ7QUFDZjtBQUMrRTtBQUMxRTtBQUUxQixTQUFTTzs7SUFDdEIsTUFBTUMsZUFBZVAsNkNBQU1BLENBQWlCO0lBQzVDLE1BQU1RLE1BQU1SLDZDQUFNQSxDQUF3QjtJQUMxQyxNQUFNUyxhQUFhVCw2Q0FBTUEsQ0FBc0IsRUFBRTtJQUNqRCxNQUFNVSxZQUFZViw2Q0FBTUEsQ0FBMEIsRUFBRTtJQUNwRCxNQUFNLENBQUNXLFVBQVVDLFlBQVksR0FBR1gsK0NBQVFBLENBQVM7SUFDakQsTUFBTVksaUJBQWlCYiw2Q0FBTUEsQ0FBUyxHQUFHLHVDQUF1Qzs7SUFFaEYsaUJBQWlCO0lBQ2pCRCxnREFBU0EsQ0FBQztRQUNSLElBQUlTLElBQUlNLE9BQU8sRUFBRSxRQUFPLHVCQUF1QjtRQUUvQyxJQUFJUCxhQUFhTyxPQUFPLEVBQUU7WUFDeEIsdUNBQXVDO1lBQ3ZDTixJQUFJTSxPQUFPLEdBQUcsSUFBSVosd0RBQWMsQ0FBQztnQkFDL0JjLFdBQVdULGFBQWFPLE9BQU87Z0JBQy9CRyxPQUFPO29CQUNMQyxTQUFTO29CQUNUQyxTQUFTO3dCQUNQLGdCQUFnQjs0QkFDZEMsTUFBTTs0QkFDTkMsT0FBTztnQ0FBQzs2QkFBaUQ7NEJBQ3pEQyxVQUFVOzRCQUNWQyxhQUFhO3dCQUNmO29CQUNGO29CQUNBQyxRQUFRO3dCQUNOOzRCQUNFQyxJQUFJOzRCQUNKTCxNQUFNOzRCQUNOTSxRQUFROzRCQUNSQyxTQUFTOzRCQUNUQyxTQUFTO3dCQUNYO3FCQUNEO2dCQUNIO2dCQUNBQyxRQUFRO29CQUFDO29CQUFHO2lCQUFFO2dCQUNkQyxNQUFNO2dCQUNOQyxPQUFPO2dCQUNQQyxTQUFTO1lBQ1g7WUFFQSxrQ0FBa0M7WUFDbEN6QixhQUFhTyxPQUFPLENBQUNHLEtBQUssQ0FBQ2dCLFVBQVUsR0FBRztZQUV4Qyx5QkFBeUI7WUFDekJ6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aEQ7R0E3UndCbEc7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9NYXBHbG9iZS50c3g/MGZmNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgbWFwbGlicmVnbCBmcm9tICdtYXBsaWJyZS1nbCdcbmltcG9ydCB7IGNhbGN1bGF0ZVRoZW9yZXRpY2FsUGluZ1RpbWUsIGZvcm1hdFBpbmdUaW1lLCBjYWxjdWxhdGVHcmVhdENpcmNsZURpc3RhbmNlIH0gZnJvbSAnQC91dGlscy9waW5nQ2FsY3VsYXRvcidcbmltcG9ydCAnbWFwbGlicmUtZ2wvZGlzdC9tYXBsaWJyZS1nbC5jc3MnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1hcEdsb2JlKCkge1xuICBjb25zdCBtYXBDb250YWluZXIgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpXG4gIGNvbnN0IG1hcCA9IHVzZVJlZjxtYXBsaWJyZWdsLk1hcCB8IG51bGw+KG51bGwpXG4gIGNvbnN0IG1hcmtlcnNSZWYgPSB1c2VSZWY8bWFwbGlicmVnbC5NYXJrZXJbXT4oW10pXG4gIGNvbnN0IHBvaW50c1JlZiA9IHVzZVJlZjxBcnJheTxbbnVtYmVyLCBudW1iZXJdPj4oW10pXG4gIGNvbnN0IFtwaW5nVGltZSwgc2V0UGluZ1RpbWVdID0gdXNlU3RhdGU8c3RyaW5nPignTi9BJylcbiAgY29uc3QgbWFya2VyQ291bnRSZWYgPSB1c2VSZWY8bnVtYmVyPigwKSAvLyBBZGQgY291bnRlciBmb3IgdG90YWwgbWFya2VycyBwbGFjZWRcbiAgXG4gIC8vIEluaXRpYWxpemUgbWFwXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKG1hcC5jdXJyZW50KSByZXR1cm4gLy8gT25seSBpbml0aWFsaXplIG9uY2VcbiAgICBcbiAgICBpZiAobWFwQ29udGFpbmVyLmN1cnJlbnQpIHtcbiAgICAgIC8vIENyZWF0ZSB0aGUgbWFwIHdpdGggYSBzdGFuZGFyZCBzdHlsZVxuICAgICAgbWFwLmN1cnJlbnQgPSBuZXcgbWFwbGlicmVnbC5NYXAoe1xuICAgICAgICBjb250YWluZXI6IG1hcENvbnRhaW5lci5jdXJyZW50LFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHZlcnNpb246IDgsXG4gICAgICAgICAgc291cmNlczoge1xuICAgICAgICAgICAgJ3Jhc3Rlci10aWxlcyc6IHtcbiAgICAgICAgICAgICAgdHlwZTogJ3Jhc3RlcicsXG4gICAgICAgICAgICAgIHRpbGVzOiBbJ2h0dHBzOi8vdGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmcnXSxcbiAgICAgICAgICAgICAgdGlsZVNpemU6IDI1NixcbiAgICAgICAgICAgICAgYXR0cmlidXRpb246ICfCqSBPcGVuU3RyZWV0TWFwIGNvbnRyaWJ1dG9ycydcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGxheWVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZDogJ3NpbXBsZS10aWxlcycsXG4gICAgICAgICAgICAgIHR5cGU6ICdyYXN0ZXInLFxuICAgICAgICAgICAgICBzb3VyY2U6ICdyYXN0ZXItdGlsZXMnLFxuICAgICAgICAgICAgICBtaW56b29tOiAwLFxuICAgICAgICAgICAgICBtYXh6b29tOiAxOVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgY2VudGVyOiBbMCwgMF0sXG4gICAgICAgIHpvb206IDEsXG4gICAgICAgIHBpdGNoOiAwLFxuICAgICAgICBiZWFyaW5nOiAwXG4gICAgICB9KVxuICAgICAgXG4gICAgICAvLyBTZXQgZGFyayBiYWNrZ3JvdW5kIGZvciB0aGUgbWFwXG4gICAgICBtYXBDb250YWluZXIuY3VycmVudC5zdHlsZS5iYWNrZ3JvdW5kID0gJyMwMDAnXG4gICAgICBcbiAgICAgIC8vIEFkZCBuYXZpZ2F0aW9uIGNvbnRyb2xcbiAgICAgIG1hcC5jdXJyZW50LmFkZENvbnRyb2wobmV3IG1hcGxpYnJlZ2wuTmF2aWdhdGlvbkNvbnRyb2woKSlcbiAgICAgIFxuICAgICAgLy8gQWRkIGF0dHJpYnV0aW9uXG4gICAgICBtYXAuY3VycmVudC5hZGRDb250cm9sKG5ldyBtYXBsaWJyZWdsLkF0dHJpYnV0aW9uQ29udHJvbCh7XG4gICAgICAgIGN1c3RvbUF0dHJpYnV0aW9uOiAnwqkgT3BlblN0cmVldE1hcCBjb250cmlidXRvcnMnXG4gICAgICB9KSwgJ2JvdHRvbS1yaWdodCcpXG4gICAgICBcbiAgICAgIC8vIEFkZCBjbGljayBoYW5kbGVyIGZvciBhZGRpbmcgbWFya2Vyc1xuICAgICAgbWFwLmN1cnJlbnQub24oJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ01hcCBjbGlja2VkIGF0OicsIGUubG5nTGF0KVxuICAgICAgICBjb25zdCB7IGxuZywgbGF0IH0gPSBlLmxuZ0xhdFxuICAgICAgICBjb25zb2xlLmxvZyhgQWRkaW5nIG1hcmtlciBhdDogbG5nPSR7bG5nfSwgbGF0PSR7bGF0fWApXG4gICAgICAgIGFkZE1hcmtlcihsbmcsIGxhdClcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIC8vIEFkZCBkZWJ1ZyBsaXN0ZW5lciBmb3IgbWFwIGxvYWRcbiAgICAgIG1hcC5jdXJyZW50Lm9uKCdsb2FkJywgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnTWFwIGxvYWRlZCcpXG4gICAgICAgIC8vIFNldCBnbG9iZSBwcm9qZWN0aW9uIGFmdGVyIG1hcCBpcyBsb2FkZWRcbiAgICAgICAgbWFwLmN1cnJlbnQ/LnNldFByb2plY3Rpb24oe1xuICAgICAgICAgIHR5cGU6ICdnbG9iZSdcbiAgICAgICAgfSlcbiAgICAgICAgY29uc29sZS5sb2coJ0dsb2JlIHByb2plY3Rpb24gc2V0JylcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIC8vIEFkZCBkZWJ1ZyBsaXN0ZW5lciBmb3Igc3R5bGUgbG9hZFxuICAgICAgbWFwLmN1cnJlbnQub24oJ3N0eWxlLmxvYWQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdNYXAgc3R5bGUgbG9hZGVkJylcbiAgICAgIH0pXG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFudXAgb24gdW5tb3VudFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBtYXJrZXJzUmVmLmN1cnJlbnQuZm9yRWFjaChtYXJrZXIgPT4gbWFya2VyLnJlbW92ZSgpKVxuICAgICAgaWYgKG1hcC5jdXJyZW50KSB7XG4gICAgICAgIG1hcC5jdXJyZW50LnJlbW92ZSgpXG4gICAgICAgIG1hcC5jdXJyZW50ID0gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfSwgW10pXG4gIFxuICAvLyBGdW5jdGlvbiB0byBhZGQgYSBtYXJrZXIgYXQgdGhlIHNwZWNpZmllZCBjb29yZGluYXRlc1xuICBjb25zdCBhZGRNYXJrZXIgPSAobG5nOiBudW1iZXIsIGxhdDogbnVtYmVyKSA9PiB7XG4gICAgaWYgKCFtYXAuY3VycmVudCkgcmV0dXJuXG4gICAgXG4gICAgY29uc29sZS5sb2coJ0FkZGluZyBtYXJrZXIgYXQ6JywgW2xuZywgbGF0XSlcbiAgICBcbiAgICAvLyBNYW5hZ2UgbWFya2VycyBkaXJlY3RseSB3aXRoIHJlZnMgaW5zdGVhZCBvZiBzdGF0ZVxuICAgIC8vIElmIHdlIGFscmVhZHkgaGF2ZSAyIG1hcmtlcnMsIHJlbW92ZSB0aGUgZmlyc3Qgb25lXG4gICAgaWYgKG1hcmtlcnNSZWYuY3VycmVudC5sZW5ndGggPj0gMikge1xuICAgICAgY29uc3Qgb2xkTWFya2VyID0gbWFya2Vyc1JlZi5jdXJyZW50LnNoaWZ0KClcbiAgICAgIG9sZE1hcmtlcj8ucmVtb3ZlKClcbiAgICAgIHBvaW50c1JlZi5jdXJyZW50LnNoaWZ0KClcbiAgICB9XG4gICAgXG4gICAgLy8gSW5jcmVtZW50IHRoZSBjb3VudGVyIGVhY2ggdGltZSBhIG5ldyBtYXJrZXIgaXMgYWRkZWRcbiAgICBtYXJrZXJDb3VudFJlZi5jdXJyZW50ICs9IDFcbiAgICBcbiAgICAvLyBEZXRlcm1pbmUgY29sb3IgYmFzZWQgb24gcG9zaXRpb24gKG9kZCBvciBldmVuKVxuICAgIGNvbnN0IG1hcmtlckNvbG9yID0gbWFya2VyQ291bnRSZWYuY3VycmVudCAlIDIgPT09IDAgPyAnI2ZmM2IzMCcgOiAnIzAwN2FmZicgLy8gUmVkIGZvciBldmVuLCBibHVlIGZvciBvZGRcbiAgICBcbiAgICAvLyBDcmVhdGUgbWFya2VyIGVsZW1lbnRcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgZWwuY2xhc3NOYW1lID0gJ21hcmtlcidcbiAgICBlbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBtYXJrZXJDb2xvclxuICAgIFxuICAgIGNvbnNvbGUubG9nKGBBZGRpbmcgJHttYXJrZXJDb2xvciA9PT0gJyNmZjNiMzAnID8gJ3JlZCcgOiAnYmx1ZSd9IG1hcmtlciwgY291bnQ6ICR7bWFya2VyQ291bnRSZWYuY3VycmVudH1gKVxuICAgIFxuICAgIC8vIENyZWF0ZSBhbmQgYWRkIHRoZSBtYXJrZXJcbiAgICBjb25zdCBtYXJrZXIgPSBuZXcgbWFwbGlicmVnbC5NYXJrZXIoe1xuICAgICAgZWxlbWVudDogZWwsXG4gICAgICBhbmNob3I6ICdjZW50ZXInXG4gICAgfSlcbiAgICAgIC5zZXRMbmdMYXQoW2xuZywgbGF0XSlcbiAgICAgIC5hZGRUbyhtYXAuY3VycmVudClcbiAgICBcbiAgICAvLyBBZGQgdG8gb3VyIHJlZnNcbiAgICBtYXJrZXJzUmVmLmN1cnJlbnQucHVzaChtYXJrZXIpXG4gICAgcG9pbnRzUmVmLmN1cnJlbnQucHVzaChbbGF0LCBsbmddIGFzIFtudW1iZXIsIG51bWJlcl0pXG4gICAgXG4gICAgY29uc29sZS5sb2coJ0N1cnJlbnQgbWFya2VycyBjb3VudDonLCBtYXJrZXJzUmVmLmN1cnJlbnQubGVuZ3RoKVxuICAgIGNvbnNvbGUubG9nKCdDdXJyZW50IHBvaW50czonLCBwb2ludHNSZWYuY3VycmVudClcbiAgICBcbiAgICAvLyBEcmF3IGxpbmUgYmV0d2VlbiBwb2ludHMgaWYgd2UgaGF2ZSBleGFjdGx5IHR3b1xuICAgIGlmIChtYXJrZXJzUmVmLmN1cnJlbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zb2xlLmxvZygnV2UgaGF2ZSAyIG1hcmtlcnMsIGRyYXdpbmcgbGluZSBhbmQgY2FsY3VsYXRpbmcgcGluZycpXG4gICAgICBkcmF3Um91dGVBbmRDYWxjdWxhdGVQaW5nKHBvaW50c1JlZi5jdXJyZW50KVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1vdmUgZXhpc3RpbmcgbGluZSBpZiBwcmVzZW50XG4gICAgICBpZiAobWFwLmN1cnJlbnQuZ2V0U291cmNlKCdyb3V0ZScpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbWFwLmN1cnJlbnQucmVtb3ZlTGF5ZXIoJ3JvdXRlLWxpbmUnKVxuICAgICAgICAgIG1hcC5jdXJyZW50LnJlbW92ZUxheWVyKCdyb3V0ZS1nbG93JylcbiAgICAgICAgICBtYXAuY3VycmVudC5yZW1vdmVTb3VyY2UoJ3JvdXRlJylcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIGV4aXN0aW5nIGxheWVyczonLCBlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICAvLyBTZXBhcmF0ZSBmdW5jdGlvbiB0byBkcmF3IHJvdXRlIGFuZCBjYWxjdWxhdGUgcGluZ1xuICBjb25zdCBkcmF3Um91dGVBbmRDYWxjdWxhdGVQaW5nID0gKHJvdXRlUG9pbnRzOiBbbnVtYmVyLCBudW1iZXJdW10pID0+IHtcbiAgICBpZiAoIW1hcC5jdXJyZW50IHx8IHJvdXRlUG9pbnRzLmxlbmd0aCAhPT0gMikgcmV0dXJuXG4gICAgXG4gICAgLy8gR2V0IGNvb3JkaW5hdGVzIGluIGNvcnJlY3QgZm9ybWF0IGZvciBjYWxjdWxhdGlvbnNcbiAgICBjb25zdCBbbGF0MSwgbG5nMV0gPSByb3V0ZVBvaW50c1swXVxuICAgIGNvbnN0IFtsYXQyLCBsbmcyXSA9IHJvdXRlUG9pbnRzWzFdXG4gICAgXG4gICAgY29uc29sZS5sb2coJ0NhbGN1bGF0aW5nIHBpbmcgdGltZSBiZXR3ZWVuOicsIFxuICAgICAgYFBvaW50IDE6ICR7bGF0MX0sICR7bG5nMX1gLFxuICAgICAgYFBvaW50IDI6ICR7bGF0Mn0sICR7bG5nMn1gXG4gICAgKVxuICAgIFxuICAgIGNvbnN0IHRpbWUgPSBjYWxjdWxhdGVUaGVvcmV0aWNhbFBpbmdUaW1lKGxhdDEsIGxuZzEsIGxhdDIsIGxuZzIpXG4gICAgY29uc3QgZGlzdGFuY2UgPSBjYWxjdWxhdGVHcmVhdENpcmNsZURpc3RhbmNlKGxhdDEsIGxuZzEsIGxhdDIsIGxuZzIpXG4gICAgXG4gICAgY29uc29sZS5sb2coJ0NhbGN1bGF0ZWQgdmFsdWVzOicsIHsgdGltZSwgZGlzdGFuY2UgfSlcbiAgICBcbiAgICAvLyBGb3JtYXQgdGhlIHBpbmcgdGltZVxuICAgIGNvbnN0IGZvcm1hdHRlZFRpbWUgPSBmb3JtYXRQaW5nVGltZSh0aW1lKVxuICAgIHNldFBpbmdUaW1lKGZvcm1hdHRlZFRpbWUpXG4gICAgXG4gICAgLy8gUmVtb3ZlIGV4aXN0aW5nIGxpbmUgaWYgcHJlc2VudFxuICAgIGlmIChtYXAuY3VycmVudC5nZXRTb3VyY2UoJ3JvdXRlJykpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1hcC5jdXJyZW50LnJlbW92ZUxheWVyKCdyb3V0ZS1saW5lJylcbiAgICAgICAgbWFwLmN1cnJlbnQucmVtb3ZlTGF5ZXIoJ3JvdXRlLWdsb3cnKVxuICAgICAgICBtYXAuY3VycmVudC5yZW1vdmVTb3VyY2UoJ3JvdXRlJylcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVtb3ZpbmcgZXhpc3RpbmcgbGF5ZXJzOicsIGUpXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCB0aGUgbmV3IGxpbmUgc291cmNlIHdpdGggY29vcmRpbmF0ZXMgaW4gW2xuZywgbGF0XSBmb3JtYXQgZm9yIEdlb0pTT05cbiAgICBtYXAuY3VycmVudC5hZGRTb3VyY2UoJ3JvdXRlJywge1xuICAgICAgdHlwZTogJ2dlb2pzb24nLFxuICAgICAgZGF0YToge1xuICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgIHR5cGU6ICdMaW5lU3RyaW5nJyxcbiAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgW2xuZzEsIGxhdDFdLCAvLyBHZW9KU09OIHVzZXMgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdIG9yZGVyXG4gICAgICAgICAgICBbbG5nMiwgbGF0Ml1cbiAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdBZGRlZCByb3V0ZSBzb3VyY2Ugd2l0aCBjb29yZGluYXRlczonLCBbXG4gICAgICBbbG5nMSwgbGF0MV0sXG4gICAgICBbbG5nMiwgbGF0Ml1cbiAgICBdKVxuICAgIFxuICAgIC8vIEFkZCB0aGUgZ2xvdyBsYXllciBmaXJzdFxuICAgIG1hcC5jdXJyZW50LmFkZExheWVyKHtcbiAgICAgIGlkOiAncm91dGUtZ2xvdycsXG4gICAgICB0eXBlOiAnbGluZScsXG4gICAgICBzb3VyY2U6ICdyb3V0ZScsXG4gICAgICBsYXlvdXQ6IHtcbiAgICAgICAgJ2xpbmUtam9pbic6ICdyb3VuZCcsXG4gICAgICAgICdsaW5lLWNhcCc6ICdyb3VuZCdcbiAgICAgIH0sXG4gICAgICBwYWludDoge1xuICAgICAgICAnbGluZS1jb2xvcic6ICcjNGRiOGZmJyxcbiAgICAgICAgJ2xpbmUtd2lkdGgnOiAxNSxcbiAgICAgICAgJ2xpbmUtb3BhY2l0eSc6IDAuOCxcbiAgICAgICAgJ2xpbmUtYmx1cic6IDE1XG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgICBjb25zb2xlLmxvZygnQWRkZWQgZ2xvdyBsYXllcicpXG4gICAgXG4gICAgLy8gQWRkIHRoZSBtYWluIGxpbmUgbGF5ZXIgb24gdG9wXG4gICAgbWFwLmN1cnJlbnQuYWRkTGF5ZXIoe1xuICAgICAgaWQ6ICdyb3V0ZS1saW5lJyxcbiAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgIHNvdXJjZTogJ3JvdXRlJyxcbiAgICAgIGxheW91dDoge1xuICAgICAgICAnbGluZS1qb2luJzogJ3JvdW5kJyxcbiAgICAgICAgJ2xpbmUtY2FwJzogJ3JvdW5kJ1xuICAgICAgfSxcbiAgICAgIHBhaW50OiB7XG4gICAgICAgICdsaW5lLWNvbG9yJzogJyNmZmZmZmYnLFxuICAgICAgICAnbGluZS13aWR0aCc6IDUsXG4gICAgICAgICdsaW5lLW9wYWNpdHknOiAxLFxuICAgICAgICAnbGluZS1kYXNoYXJyYXknOiBbMC41LCAxXVxuICAgICAgfVxuICAgIH0pXG4gICAgXG4gICAgY29uc29sZS5sb2coJ0FkZGVkIGxpbmUgbGF5ZXInKVxuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBtaWRwb2ludCBmb3IgcG9wdXBcbiAgICBjb25zdCBtaWRMYXQgPSAobGF0MSArIGxhdDIpIC8gMlxuICAgIGNvbnN0IG1pZExuZyA9IChsbmcxICsgbG5nMikgLyAyXG4gICAgXG4gICAgLy8gUmVtb3ZlIGV4aXN0aW5nIHBvcHVwc1xuICAgIGNvbnN0IGV4aXN0aW5nUG9wdXBzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgncGluZy1wb3B1cCcpXG4gICAgQXJyYXkuZnJvbShleGlzdGluZ1BvcHVwcykuZm9yRWFjaChwb3B1cCA9PiBwb3B1cC5yZW1vdmUoKSlcbiAgICBcbiAgICAvLyBBZGQgdGhlIHBpbmcgdGltZSBwb3B1cFxuICAgIG5ldyBtYXBsaWJyZWdsLlBvcHVwKHtcbiAgICAgIGNsb3NlQnV0dG9uOiBmYWxzZSxcbiAgICAgIGNsb3NlT25DbGljazogZmFsc2UsXG4gICAgICBjbGFzc05hbWU6ICdwaW5nLXBvcHVwJyxcbiAgICAgIGFuY2hvcjogJ2NlbnRlcidcbiAgICB9KVxuICAgICAgLnNldExuZ0xhdChbbWlkTG5nLCBtaWRMYXRdKVxuICAgICAgLnNldEhUTUwoYFxuICAgICAgICA8ZGl2IGNsYXNzPVwidGV4dC1jZW50ZXIgcC0yXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImZvbnQtYm9sZCB0ZXh0LWxnIHRleHQtYmx1ZS00MDBcIj4ke2Zvcm1hdHRlZFRpbWV9PC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInRleHQtc21cIj5EaXN0YW5jZTogJHtkaXN0YW5jZS50b0ZpeGVkKDApfSBrbTwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIGApXG4gICAgICAuYWRkVG8obWFwLmN1cnJlbnQpXG4gICAgXG4gICAgY29uc29sZS5sb2coJ0FkZGVkIHBvcHVwIHdpdGggcGluZyB0aW1lOicsIGZvcm1hdHRlZFRpbWUpXG4gIH1cbiAgXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5zdHJ1Y3Rpb25zIGFic29sdXRlIHRvcC00IGxlZnQtNCB6LTEwIGJnLWJsYWNrLzcwIHAtNCByb3VuZGVkLWxnIHRleHQtd2hpdGUgbWF4LXctbWRcIj5cbiAgICAgICAgPGgzIGNsYXNzTmFtZT1cInRleHQteGwgZm9udC1ib2xkIG1iLTJcIj5JbnN0cnVjdGlvbnM6PC9oMz5cbiAgICAgICAgPHA+Q2xpY2sgb24gdHdvIGRpZmZlcmVudCBsb2NhdGlvbnMgb24gdGhlIGdsb2JlIHRvIGNhbGN1bGF0ZSB0aGUgdGhlb3JldGljYWwgbWluaW11bSBwaW5nIHRpbWUgYmV0d2VlbiB0aGVtLjwvcD5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtNCBwLTIgYmctZ3JheS04MDAgcm91bmRlZFwiPlxuICAgICAgICAgIDxzcGFuPlRoZW9yZXRpY2FsIE1pbmltdW0gUGluZyBUaW1lOiA8L3NwYW4+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZm9udC1ib2xkIHRleHQteGwgdGV4dC1ibHVlLTQwMFwiPntwaW5nVGltZX08L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICBcbiAgICAgIDxkaXYgXG4gICAgICAgIHJlZj17bWFwQ29udGFpbmVyfSBcbiAgICAgICAgY2xhc3NOYW1lPVwibWFwLWNvbnRhaW5lclwiIFxuICAgICAgICBzdHlsZT17eyB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICcxMDB2aCcgfX0gXG4gICAgICAvPlxuICAgIDwvPlxuICApXG59ICJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsIm1hcGxpYnJlZ2wiLCJjYWxjdWxhdGVUaGVvcmV0aWNhbFBpbmdUaW1lIiwiZm9ybWF0UGluZ1RpbWUiLCJjYWxjdWxhdGVHcmVhdENpcmNsZURpc3RhbmNlIiwiTWFwR2xvYmUiLCJtYXBDb250YWluZXIiLCJtYXAiLCJtYXJrZXJzUmVmIiwicG9pbnRzUmVmIiwicGluZ1RpbWUiLCJzZXRQaW5nVGltZSIsIm1hcmtlckNvdW50UmVmIiwiY3VycmVudCIsIk1hcCIsImNvbnRhaW5lciIsInN0eWxlIiwidmVyc2lvbiIsInNvdXJjZXMiLCJ0eXBlIiwidGlsZXMiLCJ0aWxlU2l6ZSIsImF0dHJpYnV0aW9uIiwibGF5ZXJzIiwiaWQiLCJzb3VyY2UiLCJtaW56b29tIiwibWF4em9vbSIsImNlbnRlciIsInpvb20iLCJwaXRjaCIsImJlYXJpbmciLCJiYWNrZ3JvdW5kIiwiYWRkQ29udHJvbCIsIk5hdmlnYXRpb25Db250cm9sIiwiQXR0cmlidXRpb25Db250cm9sIiwiY3VzdG9tQXR0cmlidXRpb24iLCJvbiIsImUiLCJjb25zb2xlIiwibG9nIiwibG5nTGF0IiwibG5nIiwibGF0IiwiYWRkTWFya2VyIiwic2V0UHJvamVjdGlvbiIsImZvckVhY2giLCJtYXJrZXIiLCJyZW1vdmUiLCJsZW5ndGgiLCJvbGRNYXJrZXIiLCJzaGlmdCIsIm1hcmtlckNvbG9yIiwiZWwiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJiYWNrZ3JvdW5kQ29sb3IiLCJNYXJrZXIiLCJlbGVtZW50IiwiYW5jaG9yIiwic2V0TG5nTGF0IiwiYWRkVG8iLCJwdXNoIiwiZHJhd1JvdXRlQW5kQ2FsY3VsYXRlUGluZyIsImdldFNvdXJjZSIsInJlbW92ZUxheWVyIiwicmVtb3ZlU291cmNlIiwiZXJyb3IiLCJyb3V0ZVBvaW50cyIsImxhdDEiLCJsbmcxIiwibGF0MiIsImxuZzIiLCJ0aW1lIiwiZGlzdGFuY2UiLCJmb3JtYXR0ZWRUaW1lIiwiYWRkU291cmNlIiwiZGF0YSIsInByb3BlcnRpZXMiLCJnZW9tZXRyeSIsImNvb3JkaW5hdGVzIiwiYWRkTGF5ZXIiLCJsYXlvdXQiLCJwYWludCIsIm1pZExhdCIsIm1pZExuZyIsImV4aXN0aW5nUG9wdXBzIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsIkFycmF5IiwiZnJvbSIsInBvcHVwIiwiUG9wdXAiLCJjbG9zZUJ1dHRvbiIsImNsb3NlT25DbGljayIsInNldEhUTUwiLCJ0b0ZpeGVkIiwiZGl2IiwiaDMiLCJwIiwic3BhbiIsInJlZiIsIndpZHRoIiwiaGVpZ2h0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/MapGlobe.tsx\n"));

/***/ })

});